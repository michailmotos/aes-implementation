import random
from random import randint
from random import randrange
from fractions import gcd
import numpy as np
import binascii

#The precalculated S-box lookup table that is used during the encryption process
s_box = [0x63,0x7C,0x77,0x7B,0xF2,0x6B,0x6F,0xC5,0x30,0x01,0x67,0x2B,0xFE,0xD7,0xAB,0x76,
	0xCA,0x82,0xC9,0x7D,0xFA,0x59,0x47,0xF0,0xAD,0xD4,0xA2,0xAF,0x9C,0xA4,0x72,0xC0,
	0xB7,0xFD,0x93,0x26,0x36,0x3F,0xF7,0xCC,0x34,0xA5,0xE5,0xF1,0x71,0xD8,0x31,0x15,
	0x04,0xC7,0x23,0xC3,0x18,0x96,0x05,0x9A,0x07,0x12,0x80,0xE2,0xEB,0x27,0xB2,0x75,
	0x09,0x83,0x2C,0x1A,0x1B,0x6E,0x5A,0xA0,0x52,0x3B,0xD6,0xB3,0x29,0xE3,0x2F,0x84,
	0x53,0xD1,0x00,0xED,0x20,0xFC,0xB1,0x5B,0x6A,0xCB,0xBE,0x39,0x4A,0x4C,0x58,0xCF,
	0xD0,0xEF,0xAA,0xFB,0x43,0x4D,0x33,0x85,0x45,0xF9,0x02,0x7F,0x50,0x3C,0x9F,0xA8,
	0x51,0xA3,0x40,0x8F,0x92,0x9D,0x38,0xF5,0xBC,0xB6,0xDA,0x21,0x10,0xFF,0xF3,0xD2,
	0xCD,0x0C,0x13,0xEC,0x5F,0x97,0x44,0x17,0xC4,0xA7,0x7E,0x3D,0x64,0x5D,0x19,0x73,
	0x60,0x81,0x4F,0xDC,0x22,0x2A,0x90,0x88,0x46,0xEE,0xB8,0x14,0xDE,0x5E,0x0B,0xDB,
	0xE0,0x32,0x3A,0x0A,0x49,0x06,0x24,0x5C,0xC2,0xD3,0xAC,0x62,0x91,0x95,0xE4,0x79,
	0xE7,0xC8,0x37,0x6D,0x8D,0xD5,0x4E,0xA9,0x6C,0x56,0xF4,0xEA,0x65,0x7A,0xAE,0x08,
	0xBA,0x78,0x25,0x2E,0x1C,0xA6,0xB4,0xC6,0xE8,0xDD,0x74,0x1F,0x4B,0xBD,0x8B,0x8A,
	0x70,0x3E,0xB5,0x66,0x48,0x03,0xF6,0x0E,0x61,0x35,0x57,0xB9,0x86,0xC1,0x1D,0x9E,
	0xE1,0xF8,0x98,0x11,0x69,0xD9,0x8E,0x94,0x9B,0x1E,0x87,0xE9,0xCE,0x55,0x28,0xDF,
	0x8C,0xA1,0x89,0x0D,0xBF,0xE6,0x42,0x68,0x41,0x99,0x2D,0x0F,0xB0,0x54,0xBB,0x16]

#The precalculated Inverse S-box lookup table that is used during the decryption process
invs_box = [0x52,0x09,0x6A,0xD5,0x30,0x36,0xA5,0x38,0xBF,0x40,0xA3,0x9E,0x81,0xF3,0xD7,0xFB,
	0x7C,0xE3,0x39,0x82,0x9B,0x2F,0xFF,0x87,0x34,0x8E,0x43,0x44,0xC4,0xDE,0xE9,0xCB,
	0x54,0x7B,0x94,0x32,0xA6,0xC2,0x23,0x3D,0xEE,0x4C,0x95,0x0B,0x42,0xFA,0xC3,0x4E,
	0x08,0x2E,0xA1,0x66,0x28,0xD9,0x24,0xB2,0x76,0x5B,0xA2,0x49,0x6D,0x8B,0xD1,0x25,
	0x72,0xF8,0xF6,0x64,0x86,0x68,0x98,0x16,0xD4,0xA4,0x5C,0xCC,0x5D,0x65,0xB6,0x92,
	0x6C,0x70,0x48,0x50,0xFD,0xED,0xB9,0xDA,0x5E,0x15,0x46,0x57,0xA7,0x8D,0x9D,0x84,
	0x90,0xD8,0xAB,0x00,0x8C,0xBC,0xD3,0x0A,0xF7,0xE4,0x58,0x05,0xB8,0xB3,0x45,0x06,
	0xD0,0x2C,0x1E,0x8F,0xCA,0x3F,0x0F,0x02,0xC1,0xAF,0xBD,0x03,0x01,0x13,0x8A,0x6B,
	0x3A,0x91,0x11,0x41,0x4F,0x67,0xDC,0xEA,0x97,0xF2,0xCF,0xCE,0xF0,0xB4,0xE6,0x73,
	0x96,0xAC,0x74,0x22,0xE7,0xAD,0x35,0x85,0xE2,0xF9,0x37,0xE8,0x1C,0x75,0xDF,0x6E,
	0x47,0xF1,0x1A,0x71,0x1D,0x29,0xC5,0x89,0x6F,0xB7,0x62,0x0E,0xAA,0x18,0xBE,0x1B,
	0xFC,0x56,0x3E,0x4B,0xC6,0xD2,0x79,0x20,0x9A,0xDB,0xC0,0xFE,0x78,0xCD,0x5A,0xF4,
	0x1F,0xDD,0xA8,0x33,0x88,0x07,0xC7,0x31,0xB1,0x12,0x10,0x59,0x27,0x80,0xEC,0x5F,
	0x60,0x51,0x7F,0xA9,0x19,0xB5,0x4A,0x0D,0x2D,0xE5,0x7A,0x9F,0x93,0xC9,0x9C,0xEF,
	0xA0,0xE0,0x3B,0x4D,0xAE,0x2A,0xF5,0xB0,0xC8,0xEB,0xBB,0x3C,0x83,0x53,0x99,0x61,
	0x17,0x2B,0x04,0x7E,0xBA,0x77,0xD6,0x26,0xE1,0x69,0x14,0x63,0x55,0x21,0x0C,0x7D]

#The Galois Multiplication lookup tables -- precalculated to speed up the mix_columns function
#Multiply by 2
galois_lookup_2 = [0x00,0x02,0x04,0x06,0x08,0x0a,0x0c,0x0e,0x10,0x12,0x14,0x16,0x18,0x1a,0x1c,0x1e,
	0x20,0x22,0x24,0x26,0x28,0x2a,0x2c,0x2e,0x30,0x32,0x34,0x36,0x38,0x3a,0x3c,0x3e,
	0x40,0x42,0x44,0x46,0x48,0x4a,0x4c,0x4e,0x50,0x52,0x54,0x56,0x58,0x5a,0x5c,0x5e,
	0x60,0x62,0x64,0x66,0x68,0x6a,0x6c,0x6e,0x70,0x72,0x74,0x76,0x78,0x7a,0x7c,0x7e,
	0x80,0x82,0x84,0x86,0x88,0x8a,0x8c,0x8e,0x90,0x92,0x94,0x96,0x98,0x9a,0x9c,0x9e,
	0xa0,0xa2,0xa4,0xa6,0xa8,0xaa,0xac,0xae,0xb0,0xb2,0xb4,0xb6,0xb8,0xba,0xbc,0xbe,
	0xc0,0xc2,0xc4,0xc6,0xc8,0xca,0xcc,0xce,0xd0,0xd2,0xd4,0xd6,0xd8,0xda,0xdc,0xde,
	0xe0,0xe2,0xe4,0xe6,0xe8,0xea,0xec,0xee,0xf0,0xf2,0xf4,0xf6,0xf8,0xfa,0xfc,0xfe,
	0x1b,0x19,0x1f,0x1d,0x13,0x11,0x17,0x15,0x0b,0x09,0x0f,0x0d,0x03,0x01,0x07,0x05,
	0x3b,0x39,0x3f,0x3d,0x33,0x31,0x37,0x35,0x2b,0x29,0x2f,0x2d,0x23,0x21,0x27,0x25,
	0x5b,0x59,0x5f,0x5d,0x53,0x51,0x57,0x55,0x4b,0x49,0x4f,0x4d,0x43,0x41,0x47,0x45,
	0x7b,0x79,0x7f,0x7d,0x73,0x71,0x77,0x75,0x6b,0x69,0x6f,0x6d,0x63,0x61,0x67,0x65,
	0x9b,0x99,0x9f,0x9d,0x93,0x91,0x97,0x95,0x8b,0x89,0x8f,0x8d,0x83,0x81,0x87,0x85,
	0xbb,0xb9,0xbf,0xbd,0xb3,0xb1,0xb7,0xb5,0xab,0xa9,0xaf,0xad,0xa3,0xa1,0xa7,0xa5,
	0xdb,0xd9,0xdf,0xdd,0xd3,0xd1,0xd7,0xd5,0xcb,0xc9,0xcf,0xcd,0xc3,0xc1,0xc7,0xc5,
	0xfb,0xf9,0xff,0xfd,0xf3,0xf1,0xf7,0xf5,0xeb,0xe9,0xef,0xed,0xe3,0xe1,0xe7,0xe5]

#Multiply by 3
galois_lookup_3 = [0x00,0x03,0x06,0x05,0x0c,0x0f,0x0a,0x09,0x18,0x1b,0x1e,0x1d,0x14,0x17,0x12,0x11,
	0x30,0x33,0x36,0x35,0x3c,0x3f,0x3a,0x39,0x28,0x2b,0x2e,0x2d,0x24,0x27,0x22,0x21,
	0x60,0x63,0x66,0x65,0x6c,0x6f,0x6a,0x69,0x78,0x7b,0x7e,0x7d,0x74,0x77,0x72,0x71,
	0x50,0x53,0x56,0x55,0x5c,0x5f,0x5a,0x59,0x48,0x4b,0x4e,0x4d,0x44,0x47,0x42,0x41,
	0xc0,0xc3,0xc6,0xc5,0xcc,0xcf,0xca,0xc9,0xd8,0xdb,0xde,0xdd,0xd4,0xd7,0xd2,0xd1,
	0xf0,0xf3,0xf6,0xf5,0xfc,0xff,0xfa,0xf9,0xe8,0xeb,0xee,0xed,0xe4,0xe7,0xe2,0xe1,
	0xa0,0xa3,0xa6,0xa5,0xac,0xaf,0xaa,0xa9,0xb8,0xbb,0xbe,0xbd,0xb4,0xb7,0xb2,0xb1,
	0x90,0x93,0x96,0x95,0x9c,0x9f,0x9a,0x99,0x88,0x8b,0x8e,0x8d,0x84,0x87,0x82,0x81,
	0x9b,0x98,0x9d,0x9e,0x97,0x94,0x91,0x92,0x83,0x80,0x85,0x86,0x8f,0x8c,0x89,0x8a,
	0xab,0xa8,0xad,0xae,0xa7,0xa4,0xa1,0xa2,0xb3,0xb0,0xb5,0xb6,0xbf,0xbc,0xb9,0xba,
	0xfb,0xf8,0xfd,0xfe,0xf7,0xf4,0xf1,0xf2,0xe3,0xe0,0xe5,0xe6,0xef,0xec,0xe9,0xea,
	0xcb,0xc8,0xcd,0xce,0xc7,0xc4,0xc1,0xc2,0xd3,0xd0,0xd5,0xd6,0xdf,0xdc,0xd9,0xda,
	0x5b,0x58,0x5d,0x5e,0x57,0x54,0x51,0x52,0x43,0x40,0x45,0x46,0x4f,0x4c,0x49,0x4a,
	0x6b,0x68,0x6d,0x6e,0x67,0x64,0x61,0x62,0x73,0x70,0x75,0x76,0x7f,0x7c,0x79,0x7a,
	0x3b,0x38,0x3d,0x3e,0x37,0x34,0x31,0x32,0x23,0x20,0x25,0x26,0x2f,0x2c,0x29,0x2a,
	0x0b,0x08,0x0d,0x0e,0x07,0x04,0x01,0x02,0x13,0x10,0x15,0x16,0x1f,0x1c,0x19,0x1a]

#Multiply by 14
galois_lookup_14 = [0x00,0x0e,0x1c,0x12,0x38,0x36,0x24,0x2a,0x70,0x7e,0x6c,0x62,0x48,0x46,0x54,0x5a,
	0xe0,0xee,0xfc,0xf2,0xd8,0xd6,0xc4,0xca,0x90,0x9e,0x8c,0x82,0xa8,0xa6,0xb4,0xba,
	0xdb,0xd5,0xc7,0xc9,0xe3,0xed,0xff,0xf1,0xab,0xa5,0xb7,0xb9,0x93,0x9d,0x8f,0x81,
	0x3b,0x35,0x27,0x29,0x03,0x0d,0x1f,0x11,0x4b,0x45,0x57,0x59,0x73,0x7d,0x6f,0x61,
	0xad,0xa3,0xb1,0xbf,0x95,0x9b,0x89,0x87,0xdd,0xd3,0xc1,0xcf,0xe5,0xeb,0xf9,0xf7,
	0x4d,0x43,0x51,0x5f,0x75,0x7b,0x69,0x67,0x3d,0x33,0x21,0x2f,0x05,0x0b,0x19,0x17,
	0x76,0x78,0x6a,0x64,0x4e,0x40,0x52,0x5c,0x06,0x08,0x1a,0x14,0x3e,0x30,0x22,0x2c,
	0x96,0x98,0x8a,0x84,0xae,0xa0,0xb2,0xbc,0xe6,0xe8,0xfa,0xf4,0xde,0xd0,0xc2,0xcc,
	0x41,0x4f,0x5d,0x53,0x79,0x77,0x65,0x6b,0x31,0x3f,0x2d,0x23,0x09,0x07,0x15,0x1b,
	0xa1,0xaf,0xbd,0xb3,0x99,0x97,0x85,0x8b,0xd1,0xdf,0xcd,0xc3,0xe9,0xe7,0xf5,0xfb,
	0x9a,0x94,0x86,0x88,0xa2,0xac,0xbe,0xb0,0xea,0xe4,0xf6,0xf8,0xd2,0xdc,0xce,0xc0,
	0x7a,0x74,0x66,0x68,0x42,0x4c,0x5e,0x50,0x0a,0x04,0x16,0x18,0x32,0x3c,0x2e,0x20,
	0xec,0xe2,0xf0,0xfe,0xd4,0xda,0xc8,0xc6,0x9c,0x92,0x80,0x8e,0xa4,0xaa,0xb8,0xb6,
	0x0c,0x02,0x10,0x1e,0x34,0x3a,0x28,0x26,0x7c,0x72,0x60,0x6e,0x44,0x4a,0x58,0x56,
	0x37,0x39,0x2b,0x25,0x0f,0x01,0x13,0x1d,0x47,0x49,0x5b,0x55,0x7f,0x71,0x63,0x6d,
	0xd7,0xd9,0xcb,0xc5,0xef,0xe1,0xf3,0xfd,0xa7,0xa9,0xbb,0xb5,0x9f,0x91,0x83,0x8d]

#Multiply by 13
galois_lookup_13 = [0x00,0x0d,0x1a,0x17,0x34,0x39,0x2e,0x23,0x68,0x65,0x72,0x7f,0x5c,0x51,0x46,0x4b,
	0xd0,0xdd,0xca,0xc7,0xe4,0xe9,0xfe,0xf3,0xb8,0xb5,0xa2,0xaf,0x8c,0x81,0x96,0x9b,
	0xbb,0xb6,0xa1,0xac,0x8f,0x82,0x95,0x98,0xd3,0xde,0xc9,0xc4,0xe7,0xea,0xfd,0xf0,
	0x6b,0x66,0x71,0x7c,0x5f,0x52,0x45,0x48,0x03,0x0e,0x19,0x14,0x37,0x3a,0x2d,0x20,
	0x6d,0x60,0x77,0x7a,0x59,0x54,0x43,0x4e,0x05,0x08,0x1f,0x12,0x31,0x3c,0x2b,0x26,
	0xbd,0xb0,0xa7,0xaa,0x89,0x84,0x93,0x9e,0xd5,0xd8,0xcf,0xc2,0xe1,0xec,0xfb,0xf6,
	0xd6,0xdb,0xcc,0xc1,0xe2,0xef,0xf8,0xf5,0xbe,0xb3,0xa4,0xa9,0x8a,0x87,0x90,0x9d,
	0x06,0x0b,0x1c,0x11,0x32,0x3f,0x28,0x25,0x6e,0x63,0x74,0x79,0x5a,0x57,0x40,0x4d,
	0xda,0xd7,0xc0,0xcd,0xee,0xe3,0xf4,0xf9,0xb2,0xbf,0xa8,0xa5,0x86,0x8b,0x9c,0x91,
	0x0a,0x07,0x10,0x1d,0x3e,0x33,0x24,0x29,0x62,0x6f,0x78,0x75,0x56,0x5b,0x4c,0x41,
	0x61,0x6c,0x7b,0x76,0x55,0x58,0x4f,0x42,0x09,0x04,0x13,0x1e,0x3d,0x30,0x27,0x2a,
	0xb1,0xbc,0xab,0xa6,0x85,0x88,0x9f,0x92,0xd9,0xd4,0xc3,0xce,0xed,0xe0,0xf7,0xfa,
	0xb7,0xba,0xad,0xa0,0x83,0x8e,0x99,0x94,0xdf,0xd2,0xc5,0xc8,0xeb,0xe6,0xf1,0xfc,
	0x67,0x6a,0x7d,0x70,0x53,0x5e,0x49,0x44,0x0f,0x02,0x15,0x18,0x3b,0x36,0x21,0x2c,
	0x0c,0x01,0x16,0x1b,0x38,0x35,0x22,0x2f,0x64,0x69,0x7e,0x73,0x50,0x5d,0x4a,0x47,
	0xdc,0xd1,0xc6,0xcb,0xe8,0xe5,0xf2,0xff,0xb4,0xb9,0xae,0xa3,0x80,0x8d,0x9a,0x97]

#Multiply by 11
galois_lookup_11 = [0x00,0x0b,0x16,0x1d,0x2c,0x27,0x3a,0x31,0x58,0x53,0x4e,0x45,0x74,0x7f,0x62,0x69,
	0xb0,0xbb,0xa6,0xad,0x9c,0x97,0x8a,0x81,0xe8,0xe3,0xfe,0xf5,0xc4,0xcf,0xd2,0xd9,
	0x7b,0x70,0x6d,0x66,0x57,0x5c,0x41,0x4a,0x23,0x28,0x35,0x3e,0x0f,0x04,0x19,0x12,
	0xcb,0xc0,0xdd,0xd6,0xe7,0xec,0xf1,0xfa,0x93,0x98,0x85,0x8e,0xbf,0xb4,0xa9,0xa2,
	0xf6,0xfd,0xe0,0xeb,0xda,0xd1,0xcc,0xc7,0xae,0xa5,0xb8,0xb3,0x82,0x89,0x94,0x9f,
	0x46,0x4d,0x50,0x5b,0x6a,0x61,0x7c,0x77,0x1e,0x15,0x08,0x03,0x32,0x39,0x24,0x2f,
	0x8d,0x86,0x9b,0x90,0xa1,0xaa,0xb7,0xbc,0xd5,0xde,0xc3,0xc8,0xf9,0xf2,0xef,0xe4,
	0x3d,0x36,0x2b,0x20,0x11,0x1a,0x07,0x0c,0x65,0x6e,0x73,0x78,0x49,0x42,0x5f,0x54,
	0xf7,0xfc,0xe1,0xea,0xdb,0xd0,0xcd,0xc6,0xaf,0xa4,0xb9,0xb2,0x83,0x88,0x95,0x9e,
	0x47,0x4c,0x51,0x5a,0x6b,0x60,0x7d,0x76,0x1f,0x14,0x09,0x02,0x33,0x38,0x25,0x2e,
	0x8c,0x87,0x9a,0x91,0xa0,0xab,0xb6,0xbd,0xd4,0xdf,0xc2,0xc9,0xf8,0xf3,0xee,0xe5,
	0x3c,0x37,0x2a,0x21,0x10,0x1b,0x06,0x0d,0x64,0x6f,0x72,0x79,0x48,0x43,0x5e,0x55,
	0x01,0x0a,0x17,0x1c,0x2d,0x26,0x3b,0x30,0x59,0x52,0x4f,0x44,0x75,0x7e,0x63,0x68,
	0xb1,0xba,0xa7,0xac,0x9d,0x96,0x8b,0x80,0xe9,0xe2,0xff,0xf4,0xc5,0xce,0xd3,0xd8,
	0x7a,0x71,0x6c,0x67,0x56,0x5d,0x40,0x4b,0x22,0x29,0x34,0x3f,0x0e,0x05,0x18,0x13,
	0xca,0xc1,0xdc,0xd7,0xe6,0xed,0xf0,0xfb,0x92,0x99,0x84,0x8f,0xbe,0xb5,0xa8,0xa3]

#Multiply by 9
galois_lookup_9 = [0x00,0x09,0x12,0x1b,0x24,0x2d,0x36,0x3f,0x48,0x41,0x5a,0x53,0x6c,0x65,0x7e,0x77,
	0x90,0x99,0x82,0x8b,0xb4,0xbd,0xa6,0xaf,0xd8,0xd1,0xca,0xc3,0xfc,0xf5,0xee,0xe7,
	0x3b,0x32,0x29,0x20,0x1f,0x16,0x0d,0x04,0x73,0x7a,0x61,0x68,0x57,0x5e,0x45,0x4c,
	0xab,0xa2,0xb9,0xb0,0x8f,0x86,0x9d,0x94,0xe3,0xea,0xf1,0xf8,0xc7,0xce,0xd5,0xdc,
	0x76,0x7f,0x64,0x6d,0x52,0x5b,0x40,0x49,0x3e,0x37,0x2c,0x25,0x1a,0x13,0x08,0x01,
	0xe6,0xef,0xf4,0xfd,0xc2,0xcb,0xd0,0xd9,0xae,0xa7,0xbc,0xb5,0x8a,0x83,0x98,0x91,
	0x4d,0x44,0x5f,0x56,0x69,0x60,0x7b,0x72,0x05,0x0c,0x17,0x1e,0x21,0x28,0x33,0x3a,
	0xdd,0xd4,0xcf,0xc6,0xf9,0xf0,0xeb,0xe2,0x95,0x9c,0x87,0x8e,0xb1,0xb8,0xa3,0xaa,
	0xec,0xe5,0xfe,0xf7,0xc8,0xc1,0xda,0xd3,0xa4,0xad,0xb6,0xbf,0x80,0x89,0x92,0x9b,
	0x7c,0x75,0x6e,0x67,0x58,0x51,0x4a,0x43,0x34,0x3d,0x26,0x2f,0x10,0x19,0x02,0x0b,
	0xd7,0xde,0xc5,0xcc,0xf3,0xfa,0xe1,0xe8,0x9f,0x96,0x8d,0x84,0xbb,0xb2,0xa9,0xa0,
	0x47,0x4e,0x55,0x5c,0x63,0x6a,0x71,0x78,0x0f,0x06,0x1d,0x14,0x2b,0x22,0x39,0x30,
	0x9a,0x93,0x88,0x81,0xbe,0xb7,0xac,0xa5,0xd2,0xdb,0xc0,0xc9,0xf6,0xff,0xe4,0xed,
	0x0a,0x03,0x18,0x11,0x2e,0x27,0x3c,0x35,0x42,0x4b,0x50,0x59,0x66,0x6f,0x74,0x7d,
	0xa1,0xa8,0xb3,0xba,0x85,0x8c,0x97,0x9e,0xe9,0xe0,0xfb,0xf2,0xcd,0xc4,0xdf,0xd6,
	0x31,0x38,0x23,0x2a,0x15,0x1c,0x07,0x0e,0x79,0x70,0x6b,0x62,0x5d,0x54,0x4f,0x46]

def aes(key_list,target):
	'''
	Takes as input the key and the plaintext we want to encrypt, in a 4x4 list form.
	Calls each function needed for each step of the AES encryption algorithm.
	Iterations: 10 - as defined in the AES-128 algorithm.
	'''
	target = add_round_key(target,key_list)
	for i in range(10):
		target = sub_bytes(target)
		target = shift_row(target)
		if i != 9: #Skipping mix_columns on round 10
			target = mix_column(target) 
		key_list = expand_key(key_list,i)
		target = add_round_key(target,key_list)
	return target


def create_block(payload,index):
	'''
	Takes a string payload as input and seperates it into a 16-character block, encoding into hex at the same time.
	The index is used so we can specify when we have more than 16-characters the starting point to create more than one block.
	This function is used both for the plaintext and the key that the user inputs.

	Returns a 4x4 list.
	
	Proper create_block calls for our AES implementation, depending on index:

	create_block(text_matrix,0)
	create_block(text_matrix,16)
	create_block(text_matrix,32) etc.
	'''
	target = [[0 for x in range(4)] for x in range(4)] 	
	for y in range(4):
		for x in range(4):
			print("BEFORE:\n")
			print(payload[index])
			target[x][y] = payload[index].encode("utf-8").hex()
			print("AFTER:\n")
			print(target[x][y])
			index += 1

	return target


def add_round_key(text_matrix,key_list):
	'''
	Performs the XOR operation between the two matrices.
	Returns a 4x4 list containing hex values.
	
	Arguments must be 4x4 matrices.

	Used not only for the add_round_key step of the AES-128 algorithm, but also in our CBC mode implementation,
	to perform the XOR operation needed between plaintext and vector both during encryption and decryption.
	'''
	add_round_key = [[0 for x in range(4)] for x in range(4)]
	for y in range(4):
		for x in range(4):
			add_round_key[x][y] = hex(int(text_matrix[x][y],16) ^ int(key_list[x][y],16))[2:].zfill(2) #we first convert our hex strings to integers, perform the XOR operation and convert it back to hex
	
	return add_round_key


def sub_bytes(matrix):
	'''
	Using the S-box table that we have defined above(taken from the AES wikipedia article), we match each one of our
	hex elements to the S-box. This is simply done by converting the hex value to integer and simply returning the
	corresponding value of the S-box list.

	Function is called with a 4x4 list as an argument.
	'''
	sub_bytes = [[0 for x in range(4)] for x in range(4)]
	for y in range(4):
		for x in range(4):
			sub_bytes[x][y] = hex(s_box[int(matrix[x][y],16)])

	return sub_bytes


def shift_row(matrix):
	'''
	We shift each row of our 4x4 matrix cyclically to the left ussing offsets 0,1,2, and 3.
	Row 0 : No offset
	Row 1 : Offset 1
	Row 2 : Offset 2
	Row 3 : Offset 3
	'''
	temp = [[0 for x in range(4)] for x in range(4)] 	
	for y in range(4):
		for x in range(4):
			temp[x][y] = matrix[x][y] #a temporary helpful 4x4 matrix -- direct copy of our input matrix -- to perform our shift_row operation

	matrix[1][0] = temp[1][1]
	matrix[1][1] = temp[1][2]
	matrix[1][2] = temp[1][3]
	matrix[1][3] = temp[1][0]

	matrix[2][0] = temp[2][2]
	matrix[2][1] = temp[2][3]
	matrix[2][2] = temp[2][0]
	matrix[2][3] = temp[2][1]

	matrix[3][0] = temp[3][3]
	matrix[3][1] = temp[3][0]
	matrix[3][2] = temp[3][1]
	matrix[3][3] = temp[3][2]	

	return matrix


def mix_column(matrix):
	'''
	Performs the mix_columns step of the AES-128 algorithm, taking advantage of the precalculated Galois lookup tables.
	Specifically:
	b0 = 2a0 + 3a1 + 1a2 + 1a3
	b0 = 1a0 + 2a1 + 3a2 + 1a3
	b0 = 1a0 + 1a1 + 2a2 + 3a3
	b3 = 3a0 + 1a1 + 1a2 + 2a3
	'''
	temp = [[0 for x in range(4)] for x in range(4)] 	
	for y in range(4):
		for x in range(4):
			temp[x][y] = matrix[x][y] #a temporary direct copy of our target matrix so we can perform mix_columns function

	for y in range(4):
		matrix[0][y] = hex(galois_lookup_2[int(temp[0][y],16)] ^ galois_lookup_3[int(temp[1][y],16)] ^ int(temp[2][y],16) ^ int(temp[3][y],16))
		matrix[1][y] = hex(int(temp[0][y],16) ^ galois_lookup_2[int(temp[1][y],16)] ^ galois_lookup_3[int(temp[2][y],16)] ^ int(temp[3][y],16))
		matrix[2][y] = hex(int(temp[0][y],16) ^ int(temp[1][y],16) ^ galois_lookup_2[int(temp[2][y],16)] ^ galois_lookup_3[int(temp[3][y],16)])
		matrix[3][y] = hex(galois_lookup_3[int(temp[0][y],16)] ^ int(temp[1][y],16) ^ int(temp[2][y],16) ^ galois_lookup_2[int(temp[3][y],16)])

	return matrix


#The round constant for our key expansion - as described in the AES-128 Key Schedule section.
rcon = [0x01,0x02,0x04,0x08,0x10,0x20,0x40,0x80,0x1b,0x36]


def expand_key(matrix,rcon_idx):
	'''
	Arguments: 4x4 key matrix and the rcon index, indicating the round in which we call the Key Schedule function.
	Returns the next key in line for the next round of AES-128.
	'''
	temp = [[0 for x in range(4)] for x in range(4)] 	
	#Storing each value of Row 3 of our 4x4 matrix, to a temporary 4x4 matrix, and saving it to the corresponding index
	#performing the circular byte left shift, on our temp matrix. 
	temp[0][3] = matrix[1][3]
	temp[1][3] = matrix[2][3]
	temp[2][3] = matrix[3][3]
	temp[3][3] = matrix[0][3]
	for x in range(4): #Performing Byte substitution using S-box on our temp 4x4 matrix, for each row of it. Therefore temp is now a direct copy of input matrix, with the 
		temp[x][3] = hex(s_box[int(temp[x][3],16)]) #correct s-box substitution and left shift + s-box substitution needed for our key schedule algorithm.
		if x == 0: #If we are on the first row, we add the corresponding round constant to it, specified by index. Our first row has the correct values, since we initialize it 
			temp[x][3] = hex(int(temp[x][3],16) ^ rcon[rcon_idx]) #on the first line of our loop
	for x in range(4): #Last step of key schedule: Row 0: row0 XOR temp_row3, Row 1: row1 XOR temp_row0, Row 2: row2 XOR temp_row1, Row3: row3 XOR temp_row2
			matrix[x][0] = hex(int(matrix[x][0],16) ^ int(temp[x][3],16)) 
			matrix[x][1] = hex(int(matrix[x][1],16) ^ int(matrix[x][0],16))
			matrix[x][2] = hex(int(matrix[x][2],16) ^ int(matrix[x][1],16))
			matrix[x][3] = hex(int(matrix[x][3],16) ^ int(matrix[x][2],16))
	return matrix
	

def aes_decrypt(ciphertext,key):
	'''
	Takes as input the key and the plaintext we want to decrypt, in a 4x4 matrix form.
	Calls each function needed for each step of the AES decryption algorithm.
	Iterations: 10 - as defined in the AES-128 algorithm.
	'''
	temp_key = [[0 for x in range(4)]for x in range(4)]
	for i in range(10):
		for y in range(4):
			for x in range(4):
				temp_key[x][y] = key[x][y] #Creating a direct copy of our input key, since on decryption we want to use key10->key9 etc. We reset this every round
		for j in range(10-i):			   #by putting it into our for loop back to the first input key. With this for loop we loop key expansion 10-round number 
			temp_key = expand_key(temp_key,j)#to get the last key on the first decryption round etc.
		ciphertext = add_round_key(ciphertext,temp_key)
		if i != 0:
			ciphertext = inv_mix_column(ciphertext) #Inverse Mix Columns for every but the first round
		ciphertext = inv_shift_row(ciphertext)
		ciphertext = inv_sub_bytes(ciphertext)
	ciphertext = add_round_key(ciphertext,key)
	return ciphertext


def inv_shift_row(matrix):
	'''
	We shift each row of our 2d-list cyclically to the right ussing offsets 0,1,2, and 3.
	'''
	temp = [[0 for x in range(4)] for x in range(4)] 	
	for y in range(4):
		for x in range(4):
			temp[x][y] = matrix[x][y] #a temporary helpful 4x4 matrix so we can shift rows.
	#Shifting each row to its corresponding offset, this time to the right instead of left, to perform the inverse action
	matrix[1][0] = temp[1][3]
	matrix[1][1] = temp[1][0]
	matrix[1][2] = temp[1][1]
	matrix[1][3] = temp[1][2]

	matrix[2][0] = temp[2][2]
	matrix[2][1] = temp[2][3]
	matrix[2][2] = temp[2][0]
	matrix[2][3] = temp[2][1]

	matrix[3][0] = temp[3][1]
	matrix[3][1] = temp[3][2]
	matrix[3][2] = temp[3][3]
	matrix[3][3] = temp[3][0]	

	return matrix


def inv_sub_bytes(matrix):
	'''
	Using the Inverse S-box table that we have defined above(taken from the AES wikipedia article), we match each one of our
	hex elements to the S-box. This is simply done by converting the hex value to integer and simply returning the
	corresponding value of the S-box list.

	Function is called with a 4x4 matrix as an argument.
	Returns a 4x4 matrix
	'''
	sub_bytes = [[0 for x in range(4)] for x in range(4)]
	for y in range(4):
		for x in range(4):
			sub_bytes[x][y] = hex(invs_box[int(matrix[x][y],16)])

	return sub_bytes


def inv_mix_column(matrix):
	"""
	The Inverse Mix Columns step, practically the same as the Mix Columns, but instead we use different Galois Tables to achieve the inverse
	result. Argument input is a 4x4 matrix.
	"""
	temp = [[0 for x in range(4)] for x in range(4)] 	
	for y in range(4):
		for x in range(4):
			temp[x][y] = matrix[x][y] #a temporary direct copy of our target matrix so we can perform mix_columns function

	for y in range(4):
		matrix[0][y] = hex(galois_lookup_14[int(temp[0][y],16)] ^ galois_lookup_11[int(temp[1][y],16)] ^ galois_lookup_13[int(temp[2][y],16)] ^ galois_lookup_9[int(temp[3][y],16)])
		matrix[1][y] = hex(galois_lookup_9[int(temp[0][y],16)] ^ galois_lookup_14[int(temp[1][y],16)] ^ galois_lookup_11[int(temp[2][y],16)] ^ galois_lookup_13[int(temp[3][y],16)])
		matrix[2][y] = hex(galois_lookup_13[int(temp[0][y],16)] ^ galois_lookup_9[int(temp[1][y],16)] ^ galois_lookup_14[int(temp[2][y],16)] ^ galois_lookup_11[int(temp[3][y],16)])
		matrix[3][y] = hex(galois_lookup_11[int(temp[0][y],16)] ^ galois_lookup_13[int(temp[1][y],16)] ^ galois_lookup_9[int(temp[2][y],16)] ^ galois_lookup_14[int(temp[3][y],16)])

	return matrix


def aes_padding(string):
	'''
	Simple function that transforms the length of input string into multiples of 16, so we can use AES to encrypt.
	Using a simple flag implementation into our while loop, we constantly add /0/0... /0 to the end of our string.
	'''
	flag = 0
	while len(string) % 16 != 0:
		if flag == 0:
			string = string + "/"
			flag = 1
		else:
			string = string + "0"
			flag = 0
	return string





def aes_menu(plaintext):
	'''
	Input plaintext string is the string we want to actually encrypt. Function proceeds to create 16 length blocks of our string and encrypt them, asking for the 
	necessary information, such as the input key(user input/file input/random key generation), mode of encryption(ECB and CBC supported).
	In the end user is asked whether he wants to save the key he used to encrypt in hex form or not.
	'''
	target = [[0 for x in range(4)] for x in range(4)] 
	target = create_block(plaintext,0) #Take the first 16 characters of plaintext, and create a 4x4 hex-encoded matrix using index 0..15
	print("Key options:")
	print("Input your own key")
	rijndael = input("Enter a 128-bit key(16 characters,plaintext):")
	while len(rijndael) != 16:
		rijndael = input("Key must be 16 characters,try again:")
	key = [[0 for x in range(4)] for x in range(4)]
	key =  create_block(rijndael,0) #Take the first 16 characters of plaintext key, and create a 4x4 hex-encoded matrix using index 0..15
	temp_result = [[]]
	result = ''
	print("1. ECB") 
	print("2. CBC")
	mode = input("Pick the encryption mode: ")
	if mode == 2: #If user picks CBC mode, we input the initial vector the user wants to perform CBC with.
		vector = [[0 for x in range(4)] for x in range(4)]
		vec = input("Enter the input vector text you want CBC to be performed with(plaintext, 16 character long): ")
		while len(vec) != 16:
			vec = input("Vector must be 16 characters,try again:\n")
		vector = create_block(vec,0)
	loop = int(len(plaintext)/16)
	for i in range(0,loop):
		if mode == 2: #Performing the XOR between input string and vector *ONLY* when user picks CBC mode. We simply use the add_round_key step of AES, since it just XORs two 4x4 matrices!
			target = add_round_key(target,vector)
		temp_result = aes(key,target)
		if mode == 2:
			vector = temp_result #Vector = ciphertext 
		for y in range(4):
			for x in range(4):
				result = result + str(temp_result[x][y]) #Result is in 4x4 matrix form. We convert it to string form	
		if len(plaintext) != 16:
			plaintext = plaintext[16:] #Get the next 16 characters of our input
			target = create_block(plaintext,0) #convert it to a 4x4 hex encoded matrix
		else:
			break #exit if no more plaintext is remaining
		key =  create_block(rijndael,0)
	print("Encrypted text: " +result)
	save = input("Would you like to save the AES key to your hard disk? y/n: ")
	if save == 'y':
		f = input("Specify the file name(include the file extension):")
		file = open(f,'w')
		rijndael = hex(rijndael)   #binascii.hexlify(binascii.a2b_uu(rijndael))
		file.write(rijndael)
		file.close()
	return result

plaintext = input("Enter text:")
aes_menu(aes_padding(plaintext))